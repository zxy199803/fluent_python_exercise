"""
散列表给dict带来的优势和限制
1.键(key)必须是可散列的，即需满足
    1）支持hash()函数，并通过__hash__()方法得到的散列值不变
    2）支持通过__eq__()方法检测相等性
    3）若a==b为真，则hash(a)==hash(b)也为真。#否则会破坏恒定的散列表算法，由这些对象组成的字典和集合失去可靠性
所有用户自定义的对象默认是可散列的，其散列值由id()获取

2.字典在内存上开销巨大
散列表是稀疏的，空间上效率低下。
存放数量巨大的记录，放在由元组或具名元组构成的列表里，不要用由字典组成的列表。（避免散列表耗费的空间，不用把记录中的字段名在每个元素里存一遍）
优化往往是可维护行的对立面

3.键查询很快
空间换时间

4.键的次序取决于添加顺序
虽然键的次序不同，但只要包含的数据一样字典是相等的

5.向字典里添加新键可能改变已有键的顺序
字典扩容可能导致散列冲突，会导致新散列表中键的次序变化。
在迭代一个字典的所有键的过程中同时修改字典，可能会跳过一些键。因此不要对字典同时迭代和修改。
.keys(),.items(),.values()返回的是字典视图，返回值更像集合，具有动态特征
"""